# -*- coding: utf-8 -*-
"""tools.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H9wetoF1GvLrmY8V-w-pKKIFvaJWYOF0
"""

import numpy as np#mathe, matrix,...
import cv2 #malprogramm
import tkinter

from IPython.display import display, Javascript, Image
from js2py import eval_js
from base64 import b64decode


def take_photo():
    cam = cv2.VideoCapture(0
                             )  # öffnet Kamera

    cv2.namedWindow("test")  # erstellt Fenster mit 'test' als Titel
    # ich glaube es zeigt aber kein Fenster an. sondern es gibt es dann im hintergrund?

    while True:
        ret, frame = cam.read() #ret ist eine boolsche variable die "wahr" zurückgibt falls wahr.
        #wenn ich jetzt ein wahr habe wird die nächste if schleife ausgelassen
        # wenn das Lesen des Bildes ein Fehler ausgibt:
        if not ret:# alos wenn nicht true
            print("failed to grab frame")
            break 
        # hier geht es weiter wenn die if schleife nicht ausgeführt wird
        
        cv2.imshow("test", frame)#zeigt das bild "frame" in einem Fester mit dem namen "test"

        # Fenster offen lassen und auf Tasteneingabe warten
        k = cv2.waitKey(1)
        # Wenn ESC gedrückt wird:
        if k % 256 == 27:# das beduetet soviel wie "wenn esc gedrückt wird". warum das dass bedeutet...ka.
            # ESC pressed
            print("Escape hit, closing...")
            break  # Warten wird beendet
        # Wenn Leertaste gedrückt wird:
        elif k % 256 == 32: #das bedeutet soviel "falls leertaste gedrückt werid"....
            # SPACE pressed
            img_name = "photo.jpg"
            cv2.imwrite(img_name, frame)  # Foto wird als 'photo.jpg' gespeichert
            print("{} written!".format(img_name))
            break  # Warten wird beendet

    cam.release()  # Kamera wird geschlossen

    cv2.destroyAllWindows()  # Fenster wird geschlossen
    print('Photo captured')


def choose_teil2(links, rechts, index_teil):
    # import numpy as np
    links = np.loadtxt(links)  # txt file laden
    rechts = np.loadtxt(rechts)

    # Wenn Matrix nur 6 Einträge hat, besteht sie nur aus einer Zeile -> entweder fehlt Nase oder Teil -> nur weiter, wenn Matrix mehr als 6 Einträge
    if (rechts.size > 6) & (links.size > 6):
        position_teil_rechts = np.where(rechts == index_teil)[
            0]  # alle Indizes der Zeilen, welche ein Teil beschreiben
        position_teil_links = np.where(links == index_teil)[0]

        rechts_teil = rechts[position_teil_rechts]  # alle Teile Daten (Übergabe der bestimmten Indizes mit Teilen)
        links_teil = links[position_teil_links]

        r2 = []
        l2 = []
        c2 = []

        # zip verknüpft zwei Mengen iterativ -> in der ersten Zeile der resultierenden Matrix ist das erste Element von a und das erste Element von b usw. -> hier: erste Spalte rechts_teil ([1]: zweite Spalte -> x) und zweite Spalte
        # rechts_teil ([2]: dritte Spalte -> y) => iterative Variabeln i & j -> x & y
        # enumerate geht jedes Element (hier Zeile) durch und gibt einem die Position und den Wert aus -> z_l: Zeilenindex & (i,j): Wert
        for z_l, (i, j) in enumerate(zip(rechts_teil[:, 1], rechts_teil[:, 2])):
            r1 = []
            l1 = []
            c1 = []
            distanz = []
            for z_r, (k, l) in enumerate(zip(links_teil[:, 1], links_teil[:, 2])):
                d = np.sqrt((i - k) ** 2 + (j - l) ** 2) #berechnet Distanz zwischen den Mittelpunkten der Bounding Boxes
                #Listen werden um Distanz, zugehörige Indizes und der summierten confidence ergänzt (für alle Kombinationsmöglichkeiten)
                distanz.append(d)
                r1.append([z_r])
                l1.append([z_l])
                c1.append(rechts_teil[z_r, 5] + links_teil[z_l, 5])

            r1 = np.array(r1) #Liste in array umwandeln
            l1 = np.array(l1)
            c1 = np.array([c1]).T
            distanz = np.array([distanz]).T

            # print(r1)
            # print(l1)
            # print(c1)
            # print(distanz)

            wahl = np.concatenate((r1, l1, c1, distanz), 1) #Matrix mit allen Kombinationsmöglichkeiten  [Index im rechten Bild, Index im linken Bild, Confidence Summe, Distanz]
            # print(wahl)
            kl_distanz = np.argmin(wahl[:, 3]) #findet Zeile mit kleinstem Distanzwert und gibt den Index dieser Zeile wieder

            r2.append(wahl[kl_distanz, 0])
            l2.append(wahl[kl_distanz, 1])
            c2.append(wahl[kl_distanz, 2])

        r2 = np.array(r2)  # rechts
        l2 = np.array(l2)  # links
        c2 = np.array(c2)  # confidence
        results = np.array((r2, l2, c2)).T #final gematchte Teile [Index im rechten Bild, Index im linken Bild, Confidence Summe] -> Übersicht über alle Teile im Bild und in welcher Zeile sie in den Bildern zu finden sind
        # print(results)

        max_conf = np.max(results[:, 2])  #höchste confidence (summe)
        # print(max_conf)

        max_rowpos_rechts = int(results[np.argmax(results[:, 2]), 0])  #index des ausgewählten Teils (Teil mit höchster confidence wird ausgesucht)
        max_rowpos_links = int(results[np.argmax(results[:, 2]), 1])
        chosen = np.concatenate(([rechts_teil[max_rowpos_rechts, :]], [links_teil[max_rowpos_links, :]]), 0) #Matrix mit Koordinaten von Teil im rechten und im linken Bild
        # print(chosen)

        return results, max_conf, chosen

    else:
        print('Keine Nase vorhanden')


def calcIOU(x1, y1, w1, h1, x2, y2, w2, h2):
    if ((abs(x1 - x2) < ((w1 + w2) / 2.0)) and (abs(y1 - y2) < ((h1 + h2) / 2.0))):
        left = max((x1 - (w1 / 2.0)), (x2 - (w2 / 2.0)))
        upper = max((y1 - (h1 / 2.0)), (y2 - (h2 / 2.0)))

        right = min((x1 + (w1 / 2.0)), (x2 + (w2 / 2.0)))
        bottom = min((y1 + (h1 / 2.0)), (y2 + (h2 / 2.0)))

        inter_w = abs(left - right)
        inter_h = abs(upper - bottom)
        inter_square = inter_w * inter_h
        union_square = (w1 * h1) + (w2 * h2) - inter_square

        calcIOU = inter_square / union_square * 100
        # print("calcIOU:", calcIOU)
    else:
        # print("No intersection!")
        calcIOU = 0

    return calcIOU


def nase_teil2(links, rechts, chosen, index_nase):
    links = np.loadtxt(links)  # txt file laden
    rechts = np.loadtxt(rechts)

    position_nase_rechts = np.where(rechts == index_nase)[0]
    position_nase_links = np.where(links == index_nase)[0]

    rechts_nase = rechts[position_nase_rechts]  # alle Nase Daten rechts
    links_nase = links[position_nase_links]  # alle Nase Daten links

    nase = np.concatenate((rechts_nase, links_nase), 0)  # alle Nase Daten

    iou = []

    for row1 in chosen:
        for row2 in nase:
            iou.append(calcIOU(row1[1], row1[2], row1[3], row1[4], row2[1], row2[2], row2[3],
                               row2[4]))  # IOU score für alle Paare

    iou = np.reshape(iou, (2, int(len(iou) / 2)))
    if not np.any(iou[0, :]) or not np.any(iou[1, :]):
        print('Keine Nase für dieses Teil')
    else:
        max_colpos_rechts = np.argmax(iou[0, :])
        max_colpos_links = np.argmax(iou[1, :])
        chosen_nase = np.concatenate(([nase[max_colpos_rechts, :]], [nase[max_colpos_links, :]]), 0)

    # print(chosen_nase)

    end_result = np.concatenate((chosen, chosen_nase), 0)

    # print(end_result)

    return chosen_nase, end_result


def position_winkel2(end_result):
    n_links = end_result[3, :]
    t_links = end_result[1, :]
    n_rechts = end_result[2, :]
    t_rechts = end_result[0, :]

    delta_xlinks = abs(n_links[1] - t_links[1])
    delta_ylinks = abs(n_links[2] - t_links[2])
    delta_xrechts = abs(n_rechts[1] - t_rechts[1])
    delta_yrechts = abs(n_rechts[2] - t_rechts[2])

    if ((n_links[1] > t_links[1]) and (n_links[2] > t_links[2])):
        winkel_links = np.arctan(delta_ylinks / delta_xlinks) * 180 / np.pi
    elif ((n_links[1] < t_links[1]) and (n_links[2] > t_links[2])):
        winkel_links = np.arctan(delta_xlinks / delta_ylinks) * 180 / np.pi + 90
    elif ((n_links[1] < t_links[1]) and (n_links[2] < t_links[2])):
        winkel_links = np.arctan(delta_ylinks / delta_xlinks) * 180 / np.pi + 180
    elif ((n_links[1] > t_links[1]) and (n_links[2] < t_links[2])):
        winkel_links = np.arctan(delta_xlinks / delta_ylinks) * 180 / np.pi + 270

    if ((n_rechts[1] > t_rechts[1]) and (n_rechts[2] > t_rechts[2])):
        winkel_rechts = np.arctan(delta_yrechts / delta_xrechts) * 180 / np.pi
    elif ((n_rechts[1] < t_rechts[1]) and (n_rechts[2] > t_rechts[2])):
        winkel_rechts = np.arctan(delta_xrechts / delta_yrechts) * 180 / np.pi + 90
    elif ((n_rechts[1] < t_rechts[1]) and (n_rechts[2] < t_rechts[2])):
        winkel_rechts = np.arctan(delta_yrechts / delta_xrechts) * 180 / np.pi + 180
    elif ((n_rechts[1] > t_rechts[1]) and (n_rechts[2] < t_rechts[2])):
        winkel_rechts = np.arctan(delta_xrechts / delta_yrechts) * 180 / np.pi + 270

    return winkel_links, winkel_rechts


def plot_chosen2(img, end_result, pix_x, pix_y):
    import cv2
    from matplotlib import pyplot as plt

    # drawing box
    path = img  # rechtes Bild
    image = cv2.imread(path)
    start_point = (int(end_result[0, 1] * pix_x - 0.5 * pix_x * end_result[0, 3]) - 70,
                   int(end_result[0, 2] * pix_y - 0.5 * pix_y * end_result[0, 4]) - 70)
    end_point = (int(end_result[0, 1] * pix_x + 0.5 * pix_x * end_result[0, 3]) + 70,
                 int(end_result[0, 2] * pix_y + 0.5 * pix_y * end_result[0, 4]) + 70)
    image = cv2.rectangle(image, start_point, end_point, (0, 0, 0), 6)

    # drawing lines
    start_mln = (int(end_result[0, 1] * pix_x), int(end_result[0, 2] * pix_y))
    end_ml = (int(end_result[0, 1] * pix_x + 0.5 * pix_x * end_result[0, 3]), int(end_result[0, 2] * pix_y))
    end_nase = (int(end_result[2, 1] * pix_x), int(end_result[2, 2] * pix_y))
    image = cv2.line(image, start_mln, end_ml, (0, 0, 0), 6)
    image = cv2.line(image, start_mln, end_nase, (0, 0, 0), 6)

    # drawing angle
    winkel = position_winkel(end_result)[0]
    image = cv2.ellipse(image, start_mln, (133, 133), 0, 0, winkel, (0, 0, 0), 6)

    plt.figure(figsize=(50, 40))
    plt.imshow(image)
    plt.show()


def choose_teil(teil, index_teil):
    # teil = np.loadtxt(teil) #txt file laden

    if (teil.size > 6):
        position_teil = np.where(teil == index_teil)[0]

        teile = teil[position_teil]  # alle Teile Daten

        max_conf = np.max(teile[:, 5])  # höchste confidence (summe)
        # print(max_conf)

        max_rowpos = np.argmax(teile[:, 5])  # index des ausgewählten Teils

        chosen = teile[max_rowpos, :]
        # print(chosen)

        teile_rest = np.delete(teile, max_rowpos, 0)
        if Distanz_Check(max_rowpos):

            return max_conf, chosen, teile_rest
    else:
        print('Keine Nase vorhanden')


def nase_teil(teil, chosen, index_nase):
    # import numpy as np

    nase = teil  # txt file laden

    position_nase = np.where(nase == index_nase)[0]

    nasen = nase[position_nase]  # alle Nase Daten rechts

    iou = []

    for row2 in nasen:
        iou.append(calcIOU(chosen[1], chosen[2], chosen[3], chosen[4], row2[1], row2[2], row2[3],
                           row2[4]))  # IOU score für alle Paare

    if not np.any(iou):
        print('Keine Nase für dieses Teil')
    else:
        max_colpos = np.argmax(iou)
        chosen_nase = nasen[max_colpos, :]

    # print(chosen_nase)

    nase_rest = np.delete(nasen, max_colpos, 0)

    end_result = np.concatenate(([chosen], [chosen_nase]), 0)

    # print(end_result)

    return chosen_nase, end_result, nase_rest


def position_winkel(end_result):
    n_links = end_result[1, :]
    t_links = end_result[0, :]

    delta_xlinks = abs(n_links[1] - t_links[1])
    delta_ylinks = abs(n_links[2] - t_links[2])

    if ((n_links[1] > t_links[1]) and (n_links[2] > t_links[2])):
        winkel_links = np.arctan(delta_ylinks / delta_xlinks) * 180 / np.pi
    elif ((n_links[1] < t_links[1]) and (n_links[2] > t_links[2])):
        winkel_links = np.arctan(delta_xlinks / delta_ylinks) * 180 / np.pi + 90
    elif ((n_links[1] < t_links[1]) and (n_links[2] < t_links[2])):
        winkel_links = np.arctan(delta_ylinks / delta_xlinks) * 180 / np.pi + 180
    elif ((n_links[1] > t_links[1]) and (n_links[2] < t_links[2])):
        winkel_links = np.arctan(delta_xlinks / delta_ylinks) * 180 / np.pi + 270

    return winkel_links


def plot_chosen(img, end_result, pix_x, pix_y):
    import cv2
    import matplotlib
    from matplotlib import pyplot as plt
    matplotlib.use('TkAgg')

    # drawing box
    path = img  # rechtes Bild
    image = cv2.imread(path)
    start_point = (int(end_result[0, 1] * pix_x - 0.5 * pix_x * end_result[0, 3]) - 10,
                   int(end_result[0, 2] * pix_y - 0.5 * pix_y * end_result[0, 4]) - 10)
    end_point = (int(end_result[0, 1] * pix_x + 0.5 * pix_x * end_result[0, 3]) + 10,
                 int(end_result[0, 2] * pix_y + 0.5 * pix_y * end_result[0, 4]) + 10)
    image = cv2.rectangle(image, start_point, end_point, (102, 0, 51), 2)

    # drawing lines
    start_mln = (int(end_result[0, 1] * pix_x), int(end_result[0, 2] * pix_y))
    end_ml = (int(end_result[0, 1] * pix_x + 0.5 * pix_x * end_result[0, 3]), int(end_result[0, 2] * pix_y))
    end_nase = (int(end_result[1, 1] * pix_x), int(end_result[1, 2] * pix_y))
    image = cv2.line(image, start_mln, end_ml, (102, 0, 51), 2)
    image = cv2.line(image, start_mln, end_nase, (102, 0, 51), 2)

    # drawing angle
    winkel = position_winkel(end_result)
    image = cv2.ellipse(image, start_mln, (30, 30), 0, 0, winkel, (102, 0, 51), 2)

    plt.figure(figsize=(12, 16))
    plt.imshow(image)
    plt.show()

    # return image


def trans_coor(chosen, pixel_w, pixel_h, width, hight):
    # x coordinate of ur is y coordinate of yolo (and the other way too)

    x = chosen[2] * pixel_h  # switching y and x
    y = chosen[1] * pixel_w

    hight_mm = hight / pixel_h
    width_mm = width / pixel_w

    x_mm = x * hight_mm
    y_mm = y * width_mm

    x_final = (x_mm + 200) / 1000  # in m
    y_final = (y_mm - (width / 2)) / 1000
    z = 0

    return x_final, y_final, z

def Distanz_Check(teil,chosen):
    anzahlZeilen = len(teil)
    zuAddieren = np.eye(anzahlZeilen) #das erzeugt eine matrix mit 1er auf der querachse. Zeilen und spaltenanazl ist = Länge der eingelesenen matriy
    #zuAddieren1 = zuAddieren[zuAddieren == 1] = 1000
    neueMatrix = np.append(teil, zuAddieren, axis=1)
    anzahlSpalten = 6
    Absatand = 0
    j = 1 # j soll die spalte sein
    i = 0

    Zeile = 0 # da lege ich die zeile fest die bearbeitet wird


    while Zeile < anzahlZeilen: #

        while i < anzahlZeilen: # das soll die tabelle mit den abständen aufstellen
            #print(i) # ich zähle i (zeile) von 0 hoch
            deltaX0i = teil[Zeile, 1] - teil[i, 1] # rechne zeile 0 spalte j - zeile i spalte j
            deltaY0i = teil[Zeile, 2] - teil[i, 2]
            Absatand = deltaX0i^2 + deltaY0i^2
            Absatand = Absatand ^ 0.5
            #Absatand = round(Absatand, 2)

            neueMatrix[Zeile,i+3] = Absatand # HIer wird i als Spalte der neuen matrix und Zeile als zeile verwendet
            i = i+1 # ab hier wird die nächste zeile subtrahiert.
            #print(neueMatrix)
            Zeile = Zeile + 1 # hier zählt die zeile hoch. Jeztt wird die nächste zeile bearbeitet
            i = 0 # i ist die zeile die zum subtrahieren beutzt wird
    Abstand_Prüfer= neueMatrix(chosen)
    if Abstand_Prüfer[-1] > 0.2:
        return True
    